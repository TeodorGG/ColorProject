'use strict';

var React = require('react');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            }
        }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = { label: 0, sent: function () {
            if (t[0] & 1)
                throw t[1];
            return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f)
            throw new TypeError("Generator is already executing.");
        while (_)
            try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                    return t;
                if (y = 0, t)
                    op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0:
                    case 1:
                        t = op;
                        break;
                    case 4:
                        _.label++;
                        return { value: op[1], done: false };
                    case 5:
                        _.label++;
                        y = op[1];
                        op = [0];
                        continue;
                    case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;
                            continue;
                        }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                            _.label = op[1];
                            break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];
                            t = op;
                            break;
                        }
                        if (t && _.label < t[2]) {
                            _.label = t[2];
                            _.ops.push(op);
                            break;
                        }
                        if (t[2])
                            _.ops.pop();
                        _.trys.pop();
                        continue;
                }
                op = body.call(thisArg, _);
            }
            catch (e) {
                op = [6, e];
                y = 0;
            }
            finally {
                f = t = 0;
            }
        if (op[0] & 5)
            throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var easeInOutQuad = function (t) {
  return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
};

var TIMEOUT_DEFAULT = 100;
var DURATION_DEFAULT = 300;
var EASING_DEFAULT = easeInOutQuad;

var NOOP = function () {};

var Pager =
/** @class */
function () {
  function Pager(element, config, callback) {
    var _this = this;

    var _a, _b, _c;

    this.animating = false;
    this.snapLengthUnit = {
      x: {
        value: 100,
        unit: '%'
      }
    };
    this.lastScrollValue = {
      x: 0
    };

    this.checkScrollSpeed = function (value, axis) {
      var clear = function () {
        _this.lastScrollValue[axis] = undefined;
      };

      var newValue = value;
      var delta;

      if (_this.lastScrollValue[axis] !== null) {
        delta = newValue - _this.lastScrollValue[axis];
      } else {
        delta = 0;
      }

      _this.lastScrollValue[axis] = newValue;
      _this.scrollSpeedTimer && clearTimeout(_this.scrollSpeedTimer);
      _this.scrollSpeedTimer = window.setTimeout(clear, 100);
      return delta;
    };

    this.bindElement = function (element) {
      _this.target = element;
      _this.listenerElement = element === document.documentElement ? window : element;

      _this.listenerElement.addEventListener('scroll', _this.startAnimation, false);
    };

    this.startAnimation = function () {
      _this.speedDeltaX = _this.checkScrollSpeed(_this.target.scrollLeft, 'x');

      if (_this.animating || _this.speedDeltaX === 0) {
        return;
      }

      _this.handler(_this.target);
    };
    /**
     * scroll handler
     * this is the callback for scroll events.
     */


    this.handler = function (target) {
      // if currently this.animating, stop it. this prevents flickering.
      if (_this.animationFrame) {
        clearTimeout(_this.animationFrame);
      } // if a previous timeout exists, clear it.


      if (_this.scrollHandlerTimer) {
        // we only want to call a timeout once after scrolling..
        clearTimeout(_this.scrollHandlerTimer);
      } else {
        _this.scrollStart = {
          x: target.scrollLeft
        };
      }

      _this.scrollHandlerTimer = window.setTimeout(_this.animationHandler, _this.timeout);
    };
    /**
     * Responsible for handling the "lifecycle" of the animation
     */


    this.animationHandler = function () {
      return __awaiter(_this, void 0, void 0, function () {
        var direction, snapPoint;

        var _a, _b, _c, _d;

        return __generator(this, function (_e) {
          switch (_e.label) {
            case 0:
              // if we don't move a thing, we can ignore the timeout: if we did, there'd be another timeout added for this.scrollStart+1.
              if (((_a = this.scrollStart) === null || _a === void 0 ? void 0 : _a.x) === ((_b = this.target) === null || _b === void 0 ? void 0 : _b.scrollLeft)) {
                // ignore timeout
                return [2
                /*return*/
                ];
              }

              direction = {
                x: this.speedDeltaX > 0 ? 1 : -1
              };
              snapPoint = this.getNextSnapPoint(this.target, direction);
              (_c = this.listenerElement) === null || _c === void 0 ? void 0 : _c.removeEventListener('scroll', this.startAnimation, false);
              this.animating = true; // smoothly move to the snap point

              return [4
              /*yield*/
              , this.smoothScroll(this.target, snapPoint)];

            case 1:
              // smoothly move to the snap point
              _e.sent();

              this.animating = false;
              (_d = this.listenerElement) === null || _d === void 0 ? void 0 : _d.addEventListener('scroll', this.startAnimation, false);
              this.onAnimationEnd(this.calculateCurrentIndex()); // we just jumped to the snapPoint, so this will be our next this.scrollStart

              if (!isNaN(snapPoint.x)) {
                this.scrollStart = snapPoint;
              }

              return [2
              /*return*/
              ];
          }
        });
      });
    };
    /**
     * Calculates which "Page" is currently visible
     */


    this.calculateCurrentIndex = function () {
      var width = _this.getPagerWidth();

      var x = _this.target.scrollLeft + width;
      return Math.round(x / width) - 1;
    };
    /**
     * Get the width of the viewpager element
     */


    this.getPagerWidth = function () {
      return Math.round(_this.getXSnapLength(_this.target, _this.snapLengthUnit.x));
    };

    this.getNextSnapPoint = function (scrollView, direction) {
      // get snap length
      var snapLength = {
        x: Math.round(_this.getXSnapLength(_this.target, _this.snapLengthUnit.x))
      };
      var left = _this.target.scrollLeft; // calc current and initial snappoint

      var currentPoint = {
        x: left / snapLength.x || 1
      };
      var nextPoint = {
        x: 0
      }; // set target and bounds by direction

      nextPoint.x = _this.roundByDirection(direction.x, currentPoint.x); // calculate where to scroll

      var scrollTo = {
        x: nextPoint.x * snapLength.x
      }; // stay in bounds (minimum: 0, maxmimum: absolute height)

      scrollTo.x = _this.stayInBounds(0, scrollView.scrollWidth, scrollTo.x);
      return scrollTo;
    };

    this.roundByDirection = function (direction, currentPoint) {
      if (direction === -1) {
        // when we go up, we floor the number to jump to the next snap-point in scroll direction
        return Math.floor(currentPoint);
      } // go down, we ceil the number to jump to the next in view.


      return Math.ceil(currentPoint);
    };

    this.stayInBounds = function (min, max, destined) {
      return Math.max(Math.min(destined, max), min);
    };
    /**
     * Calculate the number of pixels needed to move, in order to scroll the next "page" into view
     * @param scrollView
     * @param declaration
     */


    this.getXSnapLength = function (scrollView, declaration) {
      var _a;

      var offset = ((_a = _this.offset) !== null && _a !== void 0 ? _a : 0) / 100;

      if (declaration.unit === 'vw') {
        // when using vw, one snap is the length of vw / 100 * value
        var width = Math.max(document.documentElement.clientWidth, window.innerWidth || 1) / 100 + offset;
        return width * declaration.value;
      } else if (declaration.unit === '%') {
        // when using %, one snap is the length of element width / 100 * value
        var width = scrollView.clientWidth / 100 + offset;
        return width * declaration.value;
      } else {
        // when using px, one snap is the length of element width / value
        var width = scrollView.clientWidth + offset;
        return width / declaration.value;
      }
    };
    /**
     * Check when scroll coordinated is at the "edge" for the scrollview
     * @param coords current coordinates
     */


    this.isEdge = function (coords) {
      return coords.x === 0 && _this.speedDeltaX === 0;
    };
    /**
     * Smoothly scroll to a position in the scroll view
     * @param scrollView
     * @param end the desired end coordinates
     * @param callback called once the smooth scroll animation is finished
     */


    this.smoothScroll = function (scrollView, end) {
      return __awaiter(_this, void 0, void 0, function () {
        var position, start, duration, startTime, step, timestamp;

        var _this = this;

        return __generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              position = function (start, end, elapsed, duration) {
                if (elapsed > duration) {
                  return end;
                }

                return start + (end - start) * _this.easing(elapsed / duration);
              };

              start = {
                x: scrollView.scrollLeft
              };
              duration = this.isEdge(start) ? 0 : this.duration;

              step = function (timestamp) {
                return __awaiter(_this, void 0, void 0, function () {
                  var elapsed, timestamp_1;
                  return __generator(this, function (_a) {
                    switch (_a.label) {
                      case 0:
                        if (!startTime) {
                          startTime = timestamp;
                        }

                        elapsed = timestamp - startTime; // change position on x-axis if result is a number.

                        if (!isNaN(end.x)) {
                          scrollView.scrollLeft = position(start.x, end.x, elapsed, duration);
                        }

                        if (!(elapsed < duration)) return [3
                        /*break*/
                        , 3];
                        return [4
                        /*yield*/
                        , this.nextFrame()];

                      case 1:
                        timestamp_1 = _a.sent();
                        return [4
                        /*yield*/
                        , step(timestamp_1)];

                      case 2:
                        _a.sent();

                        return [3
                        /*break*/
                        , 4];

                      case 3:
                        // stop execution and run the callback
                        return [2
                        /*return*/
                        , new Promise(function (resolve) {
                          resolve(end);
                        })];

                      case 4:
                        return [2
                        /*return*/
                        ];
                    }
                  });
                });
              };

              return [4
              /*yield*/
              , this.nextFrame()];

            case 1:
              timestamp = _a.sent();
              return [4
              /*yield*/
              , step(timestamp)];

            case 2:
              return [2
              /*return*/
              , _a.sent()];
          }
        });
      });
    };

    this.nextFrame = function () {
      var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
        return window.setTimeout(fn, 15);
      };

      return new Promise(function (resolve) {
        _this.animationFrame = requestAnimationFrame(resolve);
      });
    };
    /**
     * Converts a rem value to a px value
     * @param rem
     */


    this.convertRemToPixels = function (rem) {
      return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
    };
    /**
     * Removes the scroll listener
     */


    this.unbind = function () {
      var _a;

      (_a = _this.listenerElement) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', _this.startAnimation, false);
    };
    /**
     * Snaps scroll view to a specific page
     * @param index page number
     */


    this.snapTo = function (index) {
      return __awaiter(_this, void 0, void 0, function () {
        var snapPoint;

        var _a, _b;

        return __generator(this, function (_c) {
          switch (_c.label) {
            case 0:
              (_a = this.listenerElement) === null || _a === void 0 ? void 0 : _a.removeEventListener('scroll', this.startAnimation, false);
              this.animating = true;
              snapPoint = {
                x: this.getPagerWidth() * index,
                y: 0
              };
              this.speedDeltaX = 1; // smoothly move to the snap point

              return [4
              /*yield*/
              , this.smoothScroll(this.target, snapPoint)];

            case 1:
              // smoothly move to the snap point
              _c.sent(); // after moving to the snap point, rebind the scroll event handler


              this.animating = false;
              (_b = this.listenerElement) === null || _b === void 0 ? void 0 : _b.addEventListener('scroll', this.startAnimation, false);
              this.onAnimationEnd(this.calculateCurrentIndex());
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    if (config.timeout && (isNaN(config.timeout) || typeof config.timeout === 'boolean')) {
      throw new Error("Optional config property 'timeout' is not valid, expected NUMBER but found " + (typeof config.timeout).toUpperCase());
    }

    this.timeout = config.timeout || TIMEOUT_DEFAULT;

    if (config.duration && (isNaN(config.duration) || typeof config.duration === 'boolean')) {
      throw new Error("Optional config property 'duration' is not valid, expected NUMBER but found " + (typeof config.duration).toUpperCase());
    }

    this.duration = config.duration || DURATION_DEFAULT;

    if (config.easing && typeof config.easing !== 'function') {
      throw new Error("Optional config property 'easing' is not valid, expected FUNCTION but found " + (typeof config.easing).toUpperCase());
    }

    this.easing = config.easing || EASING_DEFAULT;

    if (typeof config.offset == 'number') {
      this.offset = Number(config.offset);
    } else if ((_a = String(config.offset)) === null || _a === void 0 ? void 0 : _a.includes('rem')) {
      var value = Number((_b = String(config.offset)) === null || _b === void 0 ? void 0 : _b.replace('rem', ''));

      if (!isNaN(value)) {
        this.offset = this.convertRemToPixels(value);
      } else {
        throw new Error("Optional config property 'offset' is not valid, expected valid css rem STRING");
      }
    } else if ((_c = config.offset) === null || _c === void 0 ? void 0 : _c.includes('px')) {
      var value = Number(config.offset.replace('px', ''));

      if (!isNaN(value)) {
        this.offset = value;
      } else {
        throw new Error("Optional config property 'offset' is not valid, expected valid css px STRING");
      }
    }

    this.onAnimationEnd = typeof callback === 'function' ? callback : NOOP;
    this.bindElement(element);
  }

  return Pager;
}();

function styleInject(css, ref) {
    if (ref === void 0)
        ref = {};
    var insertAt = ref.insertAt;
    if (!css || typeof document === 'undefined') {
        return;
    }
    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';
    if (insertAt === 'top') {
        if (head.firstChild) {
            head.insertBefore(style, head.firstChild);
        }
        else {
            head.appendChild(style);
        }
    }
    else {
        head.appendChild(style);
    }
    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    }
    else {
        style.appendChild(document.createTextNode(css));
    }
}

var css_248z = ".pager {\n  overflow: auto;\n  width: 100%;\n  -ms-overflow-style: none;  /* Internet Explorer 10+ */\n  scrollbar-width: none;  /* Firefox */\n\n  white-space: nowrap;\n  padding-inline-start: 0;\n}\n\n.pager::-webkit-scrollbar { \n  display: none;  /* Safari and Chrome */\n}\n\n.pager-item {\n  width: 100%;\n  display: inline-block;\n  white-space: normal;\n  vertical-align: top;\n  margin-left: 8rem;\n}\n\n.pager-item:first-child {\n  margin-left: 0rem;\n}";
styleInject(css_248z);

var ViewPager = function (_a) {
  var pages = _a.pages,
      onPageChanged = _a.onPageChanged,
      activePage = _a.activePage,
      offset = _a.offset,
      timeout = _a.timeout,
      duration = _a.duration,
      easing = _a.easing;
  var container = React.useRef(null);
  var pager = React.useRef(null);
  var doneScrolling = React.useRef(true);
  React.useEffect(function () {
    var element = container.current;
    pager.current = new Pager(element, {
      offset: offset,
      timeout: timeout,
      duration: duration,
      easing: easing
    }, function (currentItem) {
      if (element) {
        onPageChanged && onPageChanged(currentItem);
        doneScrolling.current = true;
      }
    });
    return function () {
      var _a;

      return (_a = pager.current) === null || _a === void 0 ? void 0 : _a.unbind();
    };
  }, [container]);
  React.useEffect(function () {
    var _a;

    if (doneScrolling.current) {
      doneScrolling.current = false;
      (_a = pager.current) === null || _a === void 0 ? void 0 : _a.snapTo(activePage);
    }
  }, [activePage, pager]);
  return React.createElement("div", {
    className: "pager",
    ref: container
  }, pages.map(function (page, index) {
    return React.createElement("div", {
      className: "pager-item",
      key: index
    }, page);
  }));
};

module.exports = ViewPager;
